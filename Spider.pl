#!/usr/bin/perl
use warnings;
use strict;
use threads;
use WWW::Mechanize;
use Thread::Queue;
use URI;
use 5.010;

my @urls; 
my @links;
my @form;
my %urls_done; #crawl 한 모든 utl
my %urls_keyword; #host 가 포함된 rul
my %urls_sql_form; #Form request sql weak ponit
my %urls_sql_url; #GET request sql weak point

my $url = shift || "Please provide an initial source URL";
my $max_depth = shift || 1;
my $depth=0;
my $keyword = (split /:\/\//, $url)[1]; #host filter
my $mech = WWW::Mechanize->new();

$mech->get($url);
$urls_done{$url}=1;
@form = $mech->forms; #현재 페이지의 모든 form 정보를 가져온다.
for (@form)
{
	next unless $_->action =~ /$keyword/;
	my $form_action = $_->action; #form 으로 넘겨지는 주소
	my $form_name = $_->attr('name'); #form name 
	my $form_method = $_->method; #form method
	my @form_text_name; #form 안에 존재하는 text names 을 저장하는 배열 변수
	my @inputs = $_->inputs; #form의 정보를 반환
	for (@inputs) #type 가 text 것만 @form_text_name 배열에 저장
	{
		next unless $_->type eq 'text';
		push @form_text_name, $_->name;
	}
	$urls_sql_form{$url} = join ' ', $form_action, $form_name, $form_method, @form_text_name; #key : url, value : form_action form_name form_method form_text_name(공백으로 구분)
}

@links = $mech->find_all_links; #현재 페이지의 모든 링크를 가져온다.
for my $link (@links)
{
	my $url = $link->url_abs(); #링크의 절대 주소를 저장하여 배열에 삽입
	push @urls, $url;
}

my $queue = new Thread::Queue(@urls); #@urls 인자값으로 Queue 객체 생성
$queue->enqueue('--');  #맨 뒤에 -- 구분자 삽입

while($queue->pending()>0 and $max_depth>$depth)
{
	my $url = $queue->dequeue; #queue 에서 값 하나를 빼서 반환
	if ($url eq '--')
	{
		$depth++;
		$queue->enqueue('--');
		next;
	}
	next if $urls_done{$url};
	$urls_done{$url}=1;

	if($max_depth-1>$depth) #max_depth가 1일때는 if문 안의 코드를 굳이 실행할 필요가 없어서 해당 조건 생성
	{
		$mech->get($url); # 67~91 라인까지 24~48 라인과 동일한 구문
		@form = $mech->forms;
		for (@form)
		{
			next unless $_->action =~ /$keyword/;
			my $form_action = $_->action;
			my $form_name = $_->attr('name');
			my $form_method = $_->method;
			my @form_text_name;
			my @inputs = $_->inputs;
			for (@inputs)
				{
					next unless $_->type eq 'text';
					push @form_text_name, $_->name;
				}
		$urls_sql_form{$url} = join ' ', $form_action, $form_name, $form_method, @form_text_name;
		}
		@links = $mech->find_all_links;
		for my $link (@links)
		{
			my $url = $link->url_abs();
			next if $urls_done{$url};
			$queue->enqueue($url);
		}
	}
}
for my $url (keys %urls_done)
{
	next unless $url =~ /$keyword/;
	$urls_keyword{$url}=1;
}

# GET repuset 에 매개변수가 존재하는 URL 필터링
for my $url (keys %urls_keyword)
{
	my $uri = URI->new($url);	
	my $query = $uri->query;
	next unless $query;
	$urls_sql_url{$url}= $query; #key : url, value : 매개변수와 값(ex: a=1&b=2)
}



# 매개변수 존재하는 URL 대상으로 GET request sql weak ponit 쿼리 작성
for (keys %urls_sql_url)
{
	my $abs_url = $_;
	$abs_url =~ s/=/='TEST/g;
	
	eval{ $mech->get($abs_url) }; #수정된 url로 접근
	my $response = $mech->response; #접근한 응답객체 반환
	my $content = $response->content; #응답페이지 내용 반환
	if($content =~ /(Microsoft|MySQL|ORA)/) #응답페이지 내용에 해당 문자가 있으면)
	{
		$urls_sql_url{$_} = $1;
	}
	else #없으면
	{
		delete $urls_sql_url{$_};
	}
}

# 폼이 존재하는 URL 대상으로 Form SQL waak ponit 쿼리 작성
for (keys %urls_sql_form)
{
	my $fields_query; 
	my ($action_url, $form_name, $form_method, @form_text_name) = 
		split ' ', $urls_sql_form{$_};
	for (@form_text_name) #submit_form 함수에 넣을 변수 $fields_query 설정
	{
		$fields_query .= "$_ => \"'TEST\", ";
	}
	$mech->get($_);

	my $response = $mech->submit_form(
		form_name => $form_name,
		fields =>
		{
			1 => 1,
		}
	);
	my $content = $response->content;
	if($content =~ /(Microsoft|MySQL|ORA)/i)
	{
		$urls_sql_form{$_} = $1;
	}
	else
	{
		delete $urls_sql_form{$_};
	}
}


#GET, Form 기반 sql weak point 출력
for (keys %urls_sql_form)
{
	say "$_\n\t$urls_sql_form{$_}";
}
for (keys %urls_sql_url)
{
	say "$_\n\t$urls_sql_url{$_}";
}
#for (keys %urls_keyword)
#{
#	say "urls_keyword : $_";
#}
