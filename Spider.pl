#!/usr/bin/perl
use warnings;
use strict;
use threads;
use WWW::Mechanize;
use Thread::Queue;
use 5.010;

my @urls; 
my @links;
my %urls_keyword;
my %urls_done;

my $method;
my $count;

my $url = shift || "Please provide an initial source URL";
my $max_depth = shift || 0;
my $keyword = (split /:\/\//, $url)[1];
my $mech = WWW::Mechanize->new();

$mech->get($url);
$urls_done{$url}=1;
@links = $mech->find_all_links;
for my $link (@links)
{
	my $url = $link->url_abs;
	push @urls, $url;
}

my $queue = new Thread::Queue(@urls);
my $depth=0;
$queue->enqueue('--');

while($queue->pending()>0 and $max_depth>$depth)
{
	my $url = $queue->dequeue;
	if ($url eq '--')
	{
		$depth++;
		$queue->enqueue('--');
		next;
	}
	next if $urls_done{$url};
	$mech->get($url);
	$urls_done{$url}=1;
	@links = $mech->find_all_links;
	for my $link (@links)
	{
		my $url = $link->url_abs();
		next if $urls_done{$url};
		$queue->enqueue($url);
	}
}

for (sort keys %urls_done)
{
	$count++;
	print "$count : $_\n";
}

exit;


#현재 주소의 method
#my $method = $mech->get($url)->request->method;
#$mech->get($url);
#form 정보 얻어오기
#my @form = $mech->forms;
#for (@form)
#{
#	my $form_action = $_->action // '';
#	my $form_name = $_->attr('name') // '';
#	my @form_text_name;
#	my $formmethod = $_->method;
#my @inputs = $_->inputs;
#	for (@inputs)
#	{
#		if($_->type eq 'text')
#		{
#			push @form_text_name, $_->name;
#		}
#	}
#	if(@form_text_name)
#	{
#		say "$form_name @form_text_name $form_action $formmethod";
#	}
#}

#URL 주소 찾기

for my $link ($mech->find_all_links(url_abs_regex=>qr/$keyword/))
{
	push @urls, $link->url_abs();
	say $link->url_abs();
}
for my $url (@urls)
{
	next if $urls_done{$url};
	$method = eval {$mech->get($url)->request->method};
	$urls_done{$url}=$method;
	say $url;
	for my $link ($mech->find_all_links(url_abs_regex=>qr/$keyword/))
	{
		my $url = $link->url_abs();
		next if $urls_done{$url};
		#$url_done{$url}=1;
		push @urls, $url;
	}
}
for (sort keys %urls_done)
{
	$count++;
	print "$count : $urls_done{$_} $_\n";
}
